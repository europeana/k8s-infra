<source>
    @type tail
    read_from_head true
    tag kubernetes.ingress.*
    @label @ingress
    # parsing is implemented in the filter for this tag
    format none
    path /var/log/containers/*kube-system_nginx-ingress*.log
    pos_file /var/log/ingress.log.pos
</source>

<label @ingress>
# Parsing is done here instead of at the source, so we can suppress errors when filtering
# For some reason, the parser plugin only suppresses "pattern not matched" warning when in a <filter> block
# see: https://github.com/fluent/fluentd/issues/1617

    <filter kubernetes.ingress.**>
        @type parser
        key_name message
        emit_invalid_record_to_error false
        <parse>
            # Plugin documentation: https://github.com/repeatedly/fluent-plugin-multi-format-parser#configuration
            # This is to catch messages that don't conform to the most specific pattern.
            # Matches from top to bottom, so more-specific patterns should always come first

            @type multi_format
            <pattern>
                format regexp
                expression /^.*"time_date": "(?<time>\S+)",\s?"client": "(?<client-ipv4>\S+)",\s?"host": "(?<host>\S+)",\s?"scheme": "(?<scheme>https?)",\s?"request_method": "(?<request_method>[A-Z]+)",\s?"request_uri": "(?<request_uri>\S+)",\s?"args": "(?<args>\S+)",\s?"request_id": "(?<request_id>[0-9a-fA-F]+)",\s?"status": (?<status>\d{3}),\s?"upstream_addr": "(?<upstream_addr>\S+|Empty string)",\s?"upstream_status": (?<upstream_status>\d{3}),\s?"request_time": (?<request_time>-?[\d\.]+),\s?"upstream_response_time": (?<upstream_response_time>-?[\d\.]+),\s?"upstream_connect_time": (?<upstream_connect_time>-?[\d\.]+),\s?"upstream_header_time": (?<upstream_header_time>-?[\d\.]+),\s?"user_agent": "(?<http_user_agent>.+)"}/
            </pattern>

            <pattern>
                format regexp
                expression /^.*"time_date": "(?<time>.+?)",\s?"client": "(?<client-ipv4>.+?)",\s?"host": "(?<host>.+?)",(?<log>.*)$/
            </pattern>

            <pattern>
                format regexp
                expression /^.*"time_date": "(?<time>.+?)",.+?,\s?"host": "(?<host>.+?)",(?<log>.*)$/
            </pattern>

            <pattern>
                format regexp
                expression /^.*"time_date": "(?<time>.+?)",.+?(?<log>.*)$/
            </pattern>

            <pattern>
                format regexp
                expression /^(?<log>.*)$/
            </pattern>

            time_key time
            ## time field used by buffer when pushing logs to Elasticsearch
            keep_time_key true
            time_format %Y-%m-%dT%H:%M:%S%:z
            types status:integer,upstream_status:integer,request_time:float,upstream_connect_time:float,upstream_header_time:float,upstream_response_time:float
        </parse>
    </filter>

    # Add a "fluentd_type" property to log event
    # Add a "fluentd_ingress" property to log event
    <filter kubernetes.ingress.**>
        @type record_transformer
        @id ingress_record_transformer
        enable_ruby
        <record>
            # Used to determine which ES index log is written to
            fluentd_type ingress
            europeana_cluster "#{ENV['EANA_K8S_CLUSTER']}"
            # extract wskey value if it exists
            wskey ${record["args"][/.*wskey=([^&]*)/,1]}
            # Sets property fluentd_ingress on the log event analogous to how fluentd_include is set in apps.conf
            fluentd_ingress ${record.dig("kubernetes", "annotations", "fluentd/ingress") ? record.dig("kubernetes", "annotations", "fluentd/ingress") : ("false")}
        </record>
    </filter>

    # Whitelisting: only allow messages that have fluentd_ingress set to "true"
    #<filter kubernetes.ingress.**>
    #   @type grep
    #   @id id_grep.fluentd_ingress
    #   <regexp>
    #      key fluentd_ingress
    #      pattern /^true$/
    #   </regexp>
    #</filter>

    # Blacklisting: exclude events that match the exclude pattern
    #<filter kubernetes.ingress.**>
    #   @type grep
    #   @id id_grep.fluentd_ingress
    #   <exclude>
    #      key host
    #      pattern /oai/
    #   </exclude>
    #</filter>

    <filter kubernetes.ingress.**>
        @type geoip
        geoip_lookup_keys client-ipv4
        backend_library geoip2_c
        # db path only valid in europeana/fluentd image
        geoip2_database "/usr/share/geoip/GeoLite2-City.mmdb"
        <record>
            city_name       ${city.names.en["client-ipv4"]}
            latitude        ${location.latitude["client-ipv4"]}
            longitude       ${location.longitude["client-ipv4"]}
            country_code    ${country.iso_code["client-ipv4"]}
            country_name    ${country.names.en["client-ipv4"]}
            postal_code     ${postal.code["client-ipv4"]}
            region_code     ${subdivisions.0.iso_code["client-ipv4"]}
            region_name     ${subdivisions.0.names.en["client-ipv4"]}
            skip_adding_null_record  true
        </record>
    </filter>

    # relabel and emit to @output
    <match kubernetes.ingress.**>
        @type relabel
        @label @output
    </match>

</label>
