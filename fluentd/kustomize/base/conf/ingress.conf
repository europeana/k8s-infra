<source>
    @type tail
    read_from_head true
    tag kubernetes.ingress.*
    @label @ingress
    # parsing is implemented in the filter for this tag
    format none
    path /var/log/containers/*kube-system_nginx-ingress*.log
    pos_file /var/log/ingress.log.pos
</source>

<label @ingress>
# Parsing is done here instead of at the source, so we can suppress regex/filtering issues by disabling the emit_invalid_record_to_error option
# For some reason, the parser plugin only suppresses "pattern not matched" warning when in a <filter> block
#  see: https://github.com/fluent/fluentd/issues/1617
    <filter kubernetes.ingress.**>
        @type parser
        key_name message
        emit_invalid_record_to_error true
        <parse>
            @type regexp
            # Sadly we haven't found a way to make the regex multiple line :-(
            expression /^.*"time_date": "(?<time>\S+)",\s?"client": "(?<client-ipv4>\S*)",\s?"host": "(?<host>\S*)",\s?"scheme": "(?<scheme>https?)",\s?"request_method": "(?<request_method>[A-Z]*)",\s?"request_uri": "(?<request_uri>.*?)",\s?"args": "(?<args>\S*)",\s?"request_id": "(?<request_id>[0-9a-fA-F]*)",\s?"status": (?<status>\d{3}),\s?"upstream_addr": "(?<upstream_addr>\S*)",\s?"upstream_status": (?<upstream_status>(-1|0|\d{3})),\s?"request_time": (?<request_time>-?[\d\.]*),\s?"upstream_response_time": (?<upstream_response_time>-?[\d\.]*),\s?"upstream_connect_time": (?<upstream_connect_time>-?[\d\.]*),\s?"upstream_header_time": (?<upstream_header_time>-?[\d\.]*),\s?"user_agent": "(?<http_user_agent>.*?)",\s?"http_referrer": "(?<referrer>\S*)",\s?"body_bytes_sent": (?<body_bytes_sent>[\d\.]*),\s?"cf_connecting_ip": "(?<external_client_ip>\S*)",?(?<new_fields>.*)}/
            time_key time
            # time field used by buffer when pushing logs to Elasticsearch
            keep_time_key true
            time_format %Y-%m-%dT%H:%M:%S%:z
            types status:integer,upstream_status:integer,request_time:float,upstream_connect_time:float,upstream_header_time:float,upstream_response_time:float,body_bytes_sent:integer
        </parse>
    </filter>

    # Add a "fluentd_type" property to log event
    <filter kubernetes.ingress.**>
        @type record_transformer
        @id ingress_record_transformer
        # TODO Enable ruby is not ideal for performance, see also https://docs.fluentd.org/filter/record_transformer#enable_ruby
        enable_ruby
        <record>
            # Used to determine which ES index log is written to
            fluentd_type ingress
            europeana_cluster "#{ENV['EANA_K8S_CLUSTER']}"
            # Extract wskey value if it exists
            wskey ${record["args"][/.*wskey=([^&]*)/,1]}
            # Either use external_client_ip if it exists already, or copy over client-ipv4 value
            # TODO test this
            #external_client_ip ${if record["external_client_ip"].empty? then record["client_ipv4"]; end;}
        </record>
    </filter>

    <filter kubernetes.ingress.**>
        @type geoip
        geoip_lookup_keys client-ipv4
        backend_library geoip2_c
        # db path only valid in europeana/fluentd image
        geoip2_database "/usr/share/geoip/GeoLite2-City.mmdb"
        <record>
            city_name       ${city.names.en["client-ipv4"]}
            latitude        ${location.latitude["client-ipv4"]}
            longitude       ${location.longitude["client-ipv4"]}
            country_code    ${country.iso_code["client-ipv4"]}
            country_name    ${country.names.en["client-ipv4"]}
            postal_code     ${postal.code["client-ipv4"]}
            region_code     ${subdivisions.0.iso_code["client-ipv4"]}
            region_name     ${subdivisions.0.names.en["client-ipv4"]}
            skip_adding_null_record  true
        </record>
    </filter>

    # relabel and emit to @output
    <match kubernetes.ingress.**>
        @type relabel
        @label @output
    </match>

</label>

